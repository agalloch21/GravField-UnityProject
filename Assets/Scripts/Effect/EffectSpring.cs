using System.Collections;
using System.Collections.Generic;
using System.Linq;
using SplineMesh;
using Unity.Netcode;
using UnityEngine;


[System.Serializable]
public class WaveLine
{
    public float shakeSinValue;

    public float waveLengthScaler;
    public float shakeSpeedScaler;
    public float shakeStrengthScaler;
    public float waveWidthScaler;

    //public LineRenderer lineRenderer;    
    public Transform meshTransform;
    public MeshRenderer meshRenderer;
    public Material mat;
}

public class EffectSpring : NetworkBehaviour
{
    // Basic
    public Performer performerStart;
    public Performer performerEnd;
    Transform ropeStart;
    Transform ropeEnd;
    public Vector3 springOffset;

    int springIndex;
    public int SpringIndex { get => springIndex; }
    public bool springEnabled = false;

    // Path    
    Spline spline;
    List<GameObject> wayPoints = new List<GameObject>();

    // Effect    
    //[HideInInspector]
    public WaveLine waveline;

    [Header("Effect")]
    public Vector2 wavelengthScalerRange = new Vector2(1, 4);
    public Vector2 shakeSpeedRange = new Vector2(1, 10);
    public Vector2 shakeStrengthRange = new Vector2(0.001f, 0.3f);
    public Vector2 waveWidthRange = new Vector2(0.03f, 0.2f);

    float baseRotateAngle = 0;
    public Vector2 rotateSpeedRange = new Vector2(10, 100);

    public float ropeMass = 60f;

    void Awake()
    {
        springIndex = transform.GetSiblingIndex();

        ropeStart = transform.Find("Anchors").GetChild(0);
        ropeEnd = transform.Find("Anchors").GetChild(1);
    }    

    void Start()
    {
        spline = GetComponent<Spline>();

        AssignWayPoints();

        AssignSplineNodes();

        waveline = CreateNewWaveLine();
    }

    WaveLine CreateNewWaveLine()
    {
        WaveLine waveline = new WaveLine();

        waveline.waveLengthScaler = Random.Range(0.5f, 2f);
        waveline.shakeSinValue = 0;
        waveline.shakeSpeedScaler = Random.Range(0.7f, 1.4f);
        waveline.shakeStrengthScaler = Random.Range(0.7f, 1.4f);
        waveline.waveWidthScaler = Random.Range(0.7f, 1.4f);

        waveline.meshTransform = transform.Find("generated by SplineMeshTiling");
        waveline.meshRenderer = waveline.meshTransform.GetComponentInChildren<MeshRenderer>();

        //waveline.mat = waveline.meshRenderer.material;
        waveline.mat = GetComponent<SplineMeshTiling>().material;

        return waveline;
    }

    void Update()
    {

        if (springEnabled == false) return;

        // update parameters
        UpdateParameter();

        // update spring
        UpdateRopeAnchors();

        UpdateNodes();

        UpdateSpringMass();

        // update effect
        UpdateSpringEffect();

        
    }


    void UpdateParameter()
    {
        
    }

    #region Path
    void UpdateRopeAnchors()
    {
        ropeStart.localPosition = ApplyOffset(performerStart.transform);
        ropeEnd.localPosition = ApplyOffset(performerEnd.transform);
    }

    Vector3 ApplyOffset(Transform trans)
    {
        return trans.TransformPoint(new Vector3(springOffset.x, springOffset.y, springOffset.z));
    }

    void UpdateNodes()
    {
        int i = 0;
        foreach (GameObject wayPoint in wayPoints)
        {
            var node = spline.nodes[i++];
            //if (Vector3.Distance(node.Position, transform.InverseTransformPoint(wayPoint.transform.position)) > 0.001f)
            //{
            //    node.Position = transform.InverseTransformPoint(wayPoint.transform.position);
            //    //node.Up = wayPoint.transform.up;
            //}
            node.Position = wayPoint.transform.position;
            node.Up = wayPoint.transform.up;
        }
    }
    #endregion


    

    void UpdateSpringMass()
    {
        Transform segment_root = transform.Find("Segments");
        for (int m = 0; m < segment_root.childCount; m++)
        {
            Rigidbody rigid = segment_root.GetChild(m).GetComponent<Rigidbody>();
            rigid.mass = ropeMass;// Mathf.Lerp(startMass, endMass, m / segment_root.childCount - 1);
        }

        //Transform joint_root = transform.Find("Joints");

        //JointSpring spring_settings = new JointSpring();
        //spring_settings.spring = hingeSpring;
        //spring_settings.damper = hingeDamper;
        //for (int m = 0; m < joint_root.childCount; m++)
        //{
        //    Rigidbody rigid = joint_root.GetChild(m).GetComponent<Rigidbody>();
        //    rigid.mass = jointMass;

        //    HingeJoint[] hinge_list = joint_root.GetChild(m).GetComponents<HingeJoint>();
        //    foreach (var hinge in hinge_list)
        //    {
        //        hinge.spring = spring_settings;
        //    }
        //}

        //Transform anchor_root = transform.Find("Anchors");
        //for (int m = 0; m < anchor_root.childCount; m++)
        //{
        //    Rigidbody rigid = anchor_root.GetChild(m).GetComponent<Rigidbody>();
        //    rigid.mass = anchorMass;
        //}
    }

    void UpdateSpringEffect()
    {
        float audioVolume = (performerStart.soundVolume.Value + performerEnd.soundVolume.Value) * 0.5f;
        float audioPitch = (performerStart.soundPitch.Value + performerEnd.soundPitch.Value) * 0.5f;

        Vector3 startPos = performerStart.transform.TransformPoint(springOffset);
        Vector3 endPos = performerEnd.transform.TransformPoint(springOffset);

        float dis = Vector3.Distance(startPos, endPos);
        Vector3 direction = (endPos - startPos).normalized;
        Vector3 normal = Vector3.Cross(direction, Vector3.up);


        Quaternion base_rotation = Quaternion.LookRotation(direction, Vector3.up);
        Vector3 base_angles = base_rotation.eulerAngles;

        // rotate all lines
        float rotateSpeed = Utilities.Remap(audioVolume, 0, 1, rotateSpeedRange.x, rotateSpeedRange.y);
        baseRotateAngle += Time.deltaTime * rotateSpeed;

        // wave length. we take wave length as 1, then we can use percentage as X
        float L = 1;
        float N = 1;
        float wavelength = 2 * L / N;



        // shake sin value
        float shake_speed = Utilities.Remap(audioVolume, 0, 1, shakeSpeedRange.x, shakeSpeedRange.y) * waveline.shakeSpeedScaler;
        waveline.shakeSinValue += shake_speed * Time.deltaTime;

        // shake strength
        float shake_strength = Utilities.Remap(audioVolume, 0, 1, shakeStrengthRange.x, shakeStrengthRange.y) *
            Utilities.Remap(dis, 0, 5, 1, 0.1f, true) * waveline.shakeStrengthScaler;

        // wave length
        float wavelength_scaler = Utilities.Remap(audioVolume, 0, 1, wavelengthScalerRange.x, wavelengthScalerRange.y) * waveline.waveLengthScaler;

        // wave line width
        float width = Utilities.Remap(dis, 5, 0, waveWidthRange.x, waveWidthRange.y, true) *
            Utilities.Remap(audioVolume, 0, 1, 0.8f, 1.5f) * waveline.waveWidthScaler;

        // line rotation
        float radiate_angle = baseRotateAngle + (float)springIndex / (float)transform.parent.childCount * 360;
        Quaternion rotation = Quaternion.Euler(base_angles.x, base_angles.y, base_angles.z + radiate_angle);
        Vector3 line_normal = rotation * normal;
        Vector3 forward = Vector3.Cross(direction, line_normal);

        // the logic behind Shader Graph
        //for (int i = 0; i < pointCount; i++)
        //{
        //    float per = (float)i / (float)(pointCount - 1);
        //    Vector3 pos_in_line = Vector3.Lerp(startPos, endPos, per);
        //    float disA = dis * per;
        //    float disB = dis * (1 - per);

        //    per = Utilities.Remap(per, 0f, 1f, 0.5f - wavelength_scaler * 0.5f, 0.5f + wavelength_scaler * 0.5f);
        //    float amp = shake_strength * Mathf.Sin(2 * Mathf.PI / wavelength * (per - wavelineList[m].shakeSinValue))
        //        + shake_strength * Mathf.Sin(2 * Mathf.PI / wavelength * (per + wavelineList[m].shakeSinValue));

        //    Vector3 point_normal = line_normal;//Quaternion.Euler(per * 360f, 0, 0) * line_normal;

        //    pointList[i] = pos_in_line + point_normal * amp;
        //}

        waveline.mat.SetVector("_StartPos", startPos);
        waveline.mat.SetVector("_EndPos", endPos);
        waveline.mat.SetFloat("_WaveLengthScaler", wavelength_scaler);
        waveline.mat.SetFloat("_ShakeStrength", shake_strength);
        waveline.mat.SetFloat("_ShakeSinValue", waveline.shakeSinValue);        
        //waveline.mat.SetFloat("_Width", width);
        waveline.mat.SetFloat("_Volume", audioVolume);
        waveline.mat.SetVector("_Normal", line_normal);
        //waveline.mat.SetVector("_Forward", forward);
        //waveline.mat.SetFloat("_RotateAngle", radiate_angle);


        float base_width = Utilities.Remap(dis, 5, 0, waveWidthRange.x, waveWidthRange.y, true) * waveline.waveWidthScaler;
        base_width = base_width * 10; // multiply 10 to make it match the extent as before

        float start_thickness = Utilities.Remap(performerStart.soundVolume.Value, 0, 1, 1, 5) * base_width;
        float end_thickness = Utilities.Remap(performerEnd.soundVolume.Value, 0, 1, 1, 5) * base_width;
        float currentLength = 0;
        foreach (CubicBezierCurve curve in spline.GetCurves())
        {
            float start_percentage = currentLength / spline.Length;
            currentLength += curve.Length;
            float end_percentage = currentLength / spline.Length;

            curve.n1.Scale = Vector3.one * (start_thickness + (end_thickness - start_thickness) * start_percentage);
            curve.n2.Scale = Vector3.one * (start_thickness + (end_thickness - start_thickness) * end_percentage);
        }
    }

    public void BindPerformer(Performer performer_start, Performer performer_end)
    {
        performerStart = performer_start;
        performerEnd = performer_end;
    }

    void SetSegmentMass(float v)
    {
        Transform segment_root = transform.Find("Segments");
        for(int i=0; i<segment_root.childCount; i++)
        {
            Rigidbody rigid = segment_root.GetChild(i).GetComponent<Rigidbody>();
            rigid.mass = v;
        }
    }


    public void SetSpringState(bool state)
    {
        springEnabled = state;

        waveline.meshTransform.gameObject.SetActive(state);
        //waveline.meshRenderer.enabled = state;
    }

    void AssignWayPoints()
    {
        wayPoints.Clear();
        //Transform anchor_root = transform.Find("Anchors");
        //wayPoints.Add(anchor_root.GetChild(0).gameObject);

        Transform joint_root = transform.Find("Joints");
        for (int i = 0; i < joint_root.childCount; i++)
        {
            wayPoints.Add(joint_root.GetChild(i).gameObject);
        }

        //wayPoints.Add(anchor_root.GetChild(1).gameObject);
    }

    void AssignSplineNodes()
    {
        foreach (var penisNode in wayPoints.ToList())
        {
            if (penisNode == null) wayPoints.Remove(penisNode);
        }
        int nodeCount = wayPoints.Count;
        // adjust the number of nodes in the spline.
        while (spline.nodes.Count < nodeCount)
        {
            spline.AddNode(new SplineNode(Vector3.zero, Vector3.zero));
        }
        while (spline.nodes.Count > nodeCount && spline.nodes.Count > 2)
        {
            spline.RemoveNode(spline.nodes.Last());
        }
    }

    
}
